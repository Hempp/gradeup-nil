import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import ResetPasswordPage from '@/app/(auth)/reset-password/page';

// Mock Next.js router
const mockPush = jest.fn();
jest.mock('next/navigation', () => ({
  useRouter: () => ({
    push: mockPush,
    replace: jest.fn(),
    prefetch: jest.fn(),
  }),
  usePathname: () => '/reset-password',
  useSearchParams: () => new URLSearchParams(),
}));

// Mock toast
const mockToastSuccess = jest.fn();
const mockToastError = jest.fn();
jest.mock('@/components/ui/toast', () => ({
  useToastActions: () => ({
    success: mockToastSuccess,
    error: mockToastError,
  }),
}));

// Mock Supabase client
const mockUpdateUser = jest.fn();
const mockGetSession = jest.fn();
const mockOnAuthStateChange = jest.fn();
jest.mock('@/lib/supabase/client', () => ({
  getSupabaseClient: () => ({
    auth: {
      updateUser: mockUpdateUser,
      getSession: mockGetSession,
      onAuthStateChange: mockOnAuthStateChange,
    },
  }),
}));

describe('ResetPasswordPage', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    jest.useFakeTimers();
    mockGetSession.mockResolvedValue({ data: { session: { user: { id: '123' } } }, error: null });
    mockOnAuthStateChange.mockReturnValue({ data: { subscription: { unsubscribe: jest.fn() } } });
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  describe('Loading State', () => {
    it('shows loading state while checking session', () => {
      mockGetSession.mockImplementation(() => new Promise(() => {}));
      render(<ResetPasswordPage />);

      expect(screen.getByText(/verifying reset link/i)).toBeInTheDocument();
    });
  });

  describe('Invalid Session State', () => {
    it('shows error when session is invalid', async () => {
      mockGetSession.mockResolvedValue({ data: { session: null }, error: null });

      render(<ResetPasswordPage />);

      jest.advanceTimersByTime(2100);

      await waitFor(() => {
        expect(screen.getByText(/invalid reset link/i)).toBeInTheDocument();
      });
    });

    it('shows request new link button when session is invalid', async () => {
      mockGetSession.mockResolvedValue({ data: { session: null }, error: null });

      render(<ResetPasswordPage />);

      jest.advanceTimersByTime(2100);

      await waitFor(() => {
        expect(screen.getByRole('link', { name: /request new reset link/i })).toBeInTheDocument();
      });
    });

    it('shows error on session check error', async () => {
      mockGetSession.mockResolvedValue({ data: { session: null }, error: { message: 'Session error' } });

      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByText(/invalid or expired reset link/i)).toBeInTheDocument();
      });
    });
  });

  describe('Valid Session - Form Render', () => {
    beforeEach(() => {
      mockGetSession.mockResolvedValue({ data: { session: { user: { id: '123' } } }, error: null });
    });

    it('renders the reset password form', async () => {
      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByRole('heading', { name: /set new password/i })).toBeInTheDocument();
      });

      expect(screen.getByLabelText(/new password/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/confirm password/i)).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /reset password/i })).toBeInTheDocument();
    });

    it('renders password requirements hint', async () => {
      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByText(/at least 8 characters/i)).toBeInTheDocument();
      });
    });

    it('renders back to login link', async () => {
      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByRole('link', { name: /back to login/i })).toHaveAttribute('href', '/login');
      });
    });
  });

  describe('Form Validation', () => {
    beforeEach(() => {
      mockGetSession.mockResolvedValue({ data: { session: { user: { id: '123' } } }, error: null });
    });

    it('shows error when passwords do not match', async () => {
      const user = userEvent.setup({ advanceTimers: jest.advanceTimersByTime });
      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByLabelText(/new password/i)).toBeInTheDocument();
      });

      const passwordInput = screen.getByLabelText(/new password/i);
      const confirmInput = screen.getByLabelText(/confirm password/i);
      const submitButton = screen.getByRole('button', { name: /reset password/i });

      await user.type(passwordInput, 'Password123');
      await user.type(confirmInput, 'DifferentPassword123');
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByRole('alert')).toHaveTextContent(/passwords do not match/i);
      });
    });

    it('shows error when password is too short', async () => {
      const user = userEvent.setup({ advanceTimers: jest.advanceTimersByTime });
      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByLabelText(/new password/i)).toBeInTheDocument();
      });

      const passwordInput = screen.getByLabelText(/new password/i);
      const confirmInput = screen.getByLabelText(/confirm password/i);
      const submitButton = screen.getByRole('button', { name: /reset password/i });

      await user.type(passwordInput, 'short');
      await user.type(confirmInput, 'short');
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByRole('alert')).toHaveTextContent(/at least 8 characters/i);
      });
    });

    it('clears error when user modifies password', async () => {
      const user = userEvent.setup({ advanceTimers: jest.advanceTimersByTime });
      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByLabelText(/new password/i)).toBeInTheDocument();
      });

      const passwordInput = screen.getByLabelText(/new password/i);
      const confirmInput = screen.getByLabelText(/confirm password/i);
      const submitButton = screen.getByRole('button', { name: /reset password/i });

      await user.type(passwordInput, 'short');
      await user.type(confirmInput, 'short');
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByRole('alert')).toBeInTheDocument();
      });

      await user.clear(passwordInput);
      await user.type(passwordInput, 'NewPassword123');

      expect(screen.queryByRole('alert')).not.toBeInTheDocument();
    });
  });

  describe('Form Submission', () => {
    beforeEach(() => {
      mockGetSession.mockResolvedValue({ data: { session: { user: { id: '123' } } }, error: null });
    });

    it('calls updateUser on valid submission', async () => {
      const user = userEvent.setup({ advanceTimers: jest.advanceTimersByTime });
      mockUpdateUser.mockResolvedValue({ error: null });

      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByLabelText(/new password/i)).toBeInTheDocument();
      });

      const passwordInput = screen.getByLabelText(/new password/i);
      const confirmInput = screen.getByLabelText(/confirm password/i);
      const submitButton = screen.getByRole('button', { name: /reset password/i });

      await user.type(passwordInput, 'NewPassword123');
      await user.type(confirmInput, 'NewPassword123');
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockUpdateUser).toHaveBeenCalledWith({ password: 'NewPassword123' });
      });
    });

    it('shows loading state during submission', async () => {
      const user = userEvent.setup({ advanceTimers: jest.advanceTimersByTime });
      mockUpdateUser.mockImplementation(() => new Promise(() => {}));

      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByLabelText(/new password/i)).toBeInTheDocument();
      });

      const passwordInput = screen.getByLabelText(/new password/i);
      const confirmInput = screen.getByLabelText(/confirm password/i);
      const submitButton = screen.getByRole('button', { name: /reset password/i });

      await user.type(passwordInput, 'NewPassword123');
      await user.type(confirmInput, 'NewPassword123');
      await user.click(submitButton);

      expect(submitButton).toBeDisabled();
    });
  });

  describe('Success State', () => {
    beforeEach(() => {
      mockGetSession.mockResolvedValue({ data: { session: { user: { id: '123' } } }, error: null });
    });

    it('shows success message after successful reset', async () => {
      const user = userEvent.setup({ advanceTimers: jest.advanceTimersByTime });
      mockUpdateUser.mockResolvedValue({ error: null });

      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByLabelText(/new password/i)).toBeInTheDocument();
      });

      const passwordInput = screen.getByLabelText(/new password/i);
      const confirmInput = screen.getByLabelText(/confirm password/i);
      const submitButton = screen.getByRole('button', { name: /reset password/i });

      await user.type(passwordInput, 'NewPassword123');
      await user.type(confirmInput, 'NewPassword123');
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByText(/password reset successfully/i)).toBeInTheDocument();
      });
    });

    it('shows toast on successful reset', async () => {
      const user = userEvent.setup({ advanceTimers: jest.advanceTimersByTime });
      mockUpdateUser.mockResolvedValue({ error: null });

      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByLabelText(/new password/i)).toBeInTheDocument();
      });

      const passwordInput = screen.getByLabelText(/new password/i);
      const confirmInput = screen.getByLabelText(/confirm password/i);
      const submitButton = screen.getByRole('button', { name: /reset password/i });

      await user.type(passwordInput, 'NewPassword123');
      await user.type(confirmInput, 'NewPassword123');
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockToastSuccess).toHaveBeenCalledWith('Password Updated', expect.any(String));
      });
    });

    it('redirects to login after success', async () => {
      const user = userEvent.setup({ advanceTimers: jest.advanceTimersByTime });
      mockUpdateUser.mockResolvedValue({ error: null });

      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByLabelText(/new password/i)).toBeInTheDocument();
      });

      const passwordInput = screen.getByLabelText(/new password/i);
      const confirmInput = screen.getByLabelText(/confirm password/i);
      const submitButton = screen.getByRole('button', { name: /reset password/i });

      await user.type(passwordInput, 'NewPassword123');
      await user.type(confirmInput, 'NewPassword123');
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByText(/password reset successfully/i)).toBeInTheDocument();
      });

      jest.advanceTimersByTime(3100);

      await waitFor(() => {
        expect(mockPush).toHaveBeenCalledWith('/login');
      });
    });

    it('shows go to login button in success state', async () => {
      const user = userEvent.setup({ advanceTimers: jest.advanceTimersByTime });
      mockUpdateUser.mockResolvedValue({ error: null });

      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByLabelText(/new password/i)).toBeInTheDocument();
      });

      const passwordInput = screen.getByLabelText(/new password/i);
      const confirmInput = screen.getByLabelText(/confirm password/i);
      const submitButton = screen.getByRole('button', { name: /reset password/i });

      await user.type(passwordInput, 'NewPassword123');
      await user.type(confirmInput, 'NewPassword123');
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByRole('link', { name: /go to login/i })).toBeInTheDocument();
      });
    });
  });

  describe('Error Handling', () => {
    beforeEach(() => {
      mockGetSession.mockResolvedValue({ data: { session: { user: { id: '123' } } }, error: null });
    });

    it('displays error on API failure', async () => {
      const user = userEvent.setup({ advanceTimers: jest.advanceTimersByTime });
      mockUpdateUser.mockResolvedValue({ error: { message: 'Password too weak' } });

      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByLabelText(/new password/i)).toBeInTheDocument();
      });

      const passwordInput = screen.getByLabelText(/new password/i);
      const confirmInput = screen.getByLabelText(/confirm password/i);
      const submitButton = screen.getByRole('button', { name: /reset password/i });

      await user.type(passwordInput, 'NewPassword123');
      await user.type(confirmInput, 'NewPassword123');
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByRole('alert')).toHaveTextContent('Password too weak');
      });
    });

    it('shows toast on API failure', async () => {
      const user = userEvent.setup({ advanceTimers: jest.advanceTimersByTime });
      mockUpdateUser.mockResolvedValue({ error: { message: 'Password too weak' } });

      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByLabelText(/new password/i)).toBeInTheDocument();
      });

      const passwordInput = screen.getByLabelText(/new password/i);
      const confirmInput = screen.getByLabelText(/confirm password/i);
      const submitButton = screen.getByRole('button', { name: /reset password/i });

      await user.type(passwordInput, 'NewPassword123');
      await user.type(confirmInput, 'NewPassword123');
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockToastError).toHaveBeenCalled();
      });
    });

    it('handles unexpected errors', async () => {
      const user = userEvent.setup({ advanceTimers: jest.advanceTimersByTime });
      mockUpdateUser.mockRejectedValue(new Error('Network error'));

      render(<ResetPasswordPage />);

      await waitFor(() => {
        expect(screen.getByLabelText(/new password/i)).toBeInTheDocument();
      });

      const passwordInput = screen.getByLabelText(/new password/i);
      const confirmInput = screen.getByLabelText(/confirm password/i);
      const submitButton = screen.getByRole('button', { name: /reset password/i });

      await user.type(passwordInput, 'NewPassword123');
      await user.type(confirmInput, 'NewPassword123');
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByRole('alert')).toHaveTextContent(/unexpected error/i);
      });
    });
  });
});
